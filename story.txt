There are an abundance of topics in the world of computer science, and it is likely that software engineers will need to know of a significant portion of them. However, it is unrealistic to expect them to know each topic by heart. Thus, a search engine dedicated to topics in computer science might be beneficial to have. This search engine would only crawl from credible sources and provide informational articles, relevant documentation, and solutions to coding problems. This would allow programmers to quickly search about the topics they need information and ensure the sources they retrieve are trusted and accurate. Thus, it would need to be updated somewhat frequently to compensate for aspects such as developments in the field and new/more efficient algorithms. This can be done based on the age of the pages in the collection, as we learned that freshness can result in an inefficient/unreasonable amount of crawling. When the pages are updated, new pages that are referenced will also be crawled. The text that is extracted from the documents obtained can be processed using several techniques such as stopping, stemming, identifying phrases using word n-grams or POS tagging. 

The search engine will also maintain an inverted index of all relevant possible terms that search engine users could search for. As we learned, the inverted index makes it easier to index terms from the user's query and retrieve documents related to those terms. We could further build the index by considering frequency of appearance in the documents it appears in, or even consider where the terms appear in the document (this could be useful if the term appearing earlier in the document is a better indication of importance of the term in the document). Note that the inverted index can also be used to rank documents more efficiently than other methods to store terms (spatial data structure). In addition, it is likely that this index would be very large as the amount of terms is large. It would be useful to implement compression on the index to save space on the disk or memory. This could be done using delta encoding, unary encoding, or elias delta/gamma encoding. Furthermore, when matching query terms to the index terms, we could apply several refinement methods to the query terms such as spell checking using edit distance (Damerau-Levenshtein, Soundex) or the Noisy Channel model, as well as stemming terms (as long as the index terms are also stemmed) to improve flexibility and potentially effectiveness of the query results.
